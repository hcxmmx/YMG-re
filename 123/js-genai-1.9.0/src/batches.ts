/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import {ApiClient} from './_api_client.js';
import * as common from './_common.js';
import {BaseModule} from './_common.js';
import * as converters from './converters/_batches_converters.js';
import {PagedItem, Pager} from './pagers.js';
import * as types from './types.js';

export class Batches extends BaseModule {
  constructor(private readonly apiClient: ApiClient) {
    super();
  }

  /**
   * Create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   * @example
   * ```ts
   * const response = await ai.batches.create({
   *   model: 'gemini-2.0-flash',
   *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},
   *   config: {
   *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},
   *   }
   * });
   * console.log(response);
   * ```
   */
  create = async (
    params: types.CreateBatchJobParameters,
  ): Promise<types.BatchJob> => {
    if (this.apiClient.isVertexAI()) {
      const timestamp = Date.now();
      const timestampStr = timestamp.toString();
      if (Array.isArray(params.src)) {
        throw new Error(
          'InlinedRequest[] is not supported in Vertex AI. Please use ' +
            'Google Cloud Storage URI or BigQuery URI instead.',
        );
      }
      params.config = params.config || {};
      if (params.config.displayName === undefined) {
        params.config.displayName = 'genaiBatchJob_${timestampStr}';
      }
      if (params.config.dest === undefined && typeof params.src === 'string') {
        if (params.src.startsWith('gs://') && params.src.endsWith('.jsonl')) {
          params.config.dest = `${params.src.slice(0, -6)}/dest`;
        } else if (params.src.startsWith('bq://')) {
          params.config.dest =
            `${params.src}_dest_${timestampStr}` as unknown as string;
        } else {
          throw new Error('Unsupported source:' + params.src);
        }
      }
    }
    return await this.createInternal(params);
  };

  /**
   * Lists batch job configurations.
   *
   * @param params - The parameters for the list request.
   * @return The paginated results of the list of batch jobs.
   *
   * @example
   * ```ts
   * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});
   * for await (const batchJob of batchJobs) {
   *   console.log(batchJob);
   * }
   * ```
   */
  list = async (
    params: types.ListBatchJobsParameters = {},
  ): Promise<Pager<types.BatchJob>> => {
    return new Pager<types.BatchJob>(
      PagedItem.PAGED_ITEM_BATCH_JOBS,
      (x: types.ListBatchJobsParameters) => this.listInternal(x),
      await this.listInternal(params),
      params,
    );
  };

  /**
   * Internal method to create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   */
  private async createInternal(
    params: types.CreateBatchJobParameters,
  ): Promise<types.BatchJob> {
    let response: Promise<types.BatchJob>;

    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = converters.createBatchJobParametersToVertex(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batchPredictionJobs',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.BatchJob>;

      return response.then((apiResponse) => {
        const resp = converters.batchJobFromVertex(apiResponse);

        return resp as types.BatchJob;
      });
    } else {
      const body = converters.createBatchJobParametersToMldev(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        '{model}:batchGenerateContent',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.BatchJob>;

      return response.then((apiResponse) => {
        const resp = converters.batchJobFromMldev(apiResponse);

        return resp as types.BatchJob;
      });
    }
  }

  /**
   * Gets batch job configurations.
   *
   * @param params - The parameters for the get request.
   * @return The batch job.
   *
   * @example
   * ```ts
   * await ai.batches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(params: types.GetBatchJobParameters): Promise<types.BatchJob> {
    let response: Promise<types.BatchJob>;

    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = converters.getBatchJobParametersToVertex(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batchPredictionJobs/{name}',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'GET',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.BatchJob>;

      return response.then((apiResponse) => {
        const resp = converters.batchJobFromVertex(apiResponse);

        return resp as types.BatchJob;
      });
    } else {
      const body = converters.getBatchJobParametersToMldev(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batches/{name}',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'GET',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.BatchJob>;

      return response.then((apiResponse) => {
        const resp = converters.batchJobFromMldev(apiResponse);

        return resp as types.BatchJob;
      });
    }
  }

  /**
   * Cancels a batch job.
   *
   * @param params - The parameters for the cancel request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
   * ```
   */
  async cancel(params: types.CancelBatchJobParameters): Promise<void> {
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = converters.cancelBatchJobParametersToVertex(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batchPredictionJobs/{name}:cancel',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      await this.apiClient.request({
        path: path,
        queryParams: queryParams,
        body: JSON.stringify(body),
        httpMethod: 'POST',
        httpOptions: params.config?.httpOptions,
        abortSignal: params.config?.abortSignal,
      });
    } else {
      const body = converters.cancelBatchJobParametersToMldev(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batches/{name}:cancel',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      await this.apiClient.request({
        path: path,
        queryParams: queryParams,
        body: JSON.stringify(body),
        httpMethod: 'POST',
        httpOptions: params.config?.httpOptions,
        abortSignal: params.config?.abortSignal,
      });
    }
  }

  private async listInternal(
    params: types.ListBatchJobsParameters,
  ): Promise<types.ListBatchJobsResponse> {
    let response: Promise<types.ListBatchJobsResponse>;

    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = converters.listBatchJobsParametersToVertex(params);
      path = common.formatMap(
        'batchPredictionJobs',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'GET',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.ListBatchJobsResponse>;

      return response.then((apiResponse) => {
        const resp = converters.listBatchJobsResponseFromVertex(apiResponse);
        const typedResp = new types.ListBatchJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = converters.listBatchJobsParametersToMldev(params);
      path = common.formatMap(
        'batches',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'GET',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.ListBatchJobsResponse>;

      return response.then((apiResponse) => {
        const resp = converters.listBatchJobsResponseFromMldev(apiResponse);
        const typedResp = new types.ListBatchJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  /**
   * Deletes a batch job.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(
    params: types.DeleteBatchJobParameters,
  ): Promise<types.DeleteResourceJob> {
    let response: Promise<types.DeleteResourceJob>;

    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = converters.deleteBatchJobParametersToVertex(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batchPredictionJobs/{name}',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'DELETE',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.DeleteResourceJob>;

      return response.then((apiResponse) => {
        const resp = converters.deleteResourceJobFromVertex(apiResponse);

        return resp as types.DeleteResourceJob;
      });
    } else {
      const body = converters.deleteBatchJobParametersToMldev(
        this.apiClient,
        params,
      );
      path = common.formatMap(
        'batches/{name}',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'DELETE',
          httpOptions: params.config?.httpOptions,
          abortSignal: params.config?.abortSignal,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.DeleteResourceJob>;

      return response.then((apiResponse) => {
        const resp = converters.deleteResourceJobFromMldev(apiResponse);

        return resp as types.DeleteResourceJob;
      });
    }
  }
}
